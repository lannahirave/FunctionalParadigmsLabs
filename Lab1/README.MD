# Реалізувати мовою функціонального програмування задачу згідно варіанту.

Обмеження 1: мова Haskell, [Common] Lisp на вибір (інші за узгодженням).
Обмеження 2: використання довільних імперативних конструкцій (станів пам'яті, присвоювань, циклів) заборонено; задача має бути розв'язана в "чистих" функціях.
Рекурсія заохочується.

На захисті цієї лабораторної треба
0) розповісти умову задачі
1) розповісти про використовувані зображення даних
2) розповісти по алгоритм
3) продемонструвати роботу коду
4) відповіді на питання за пп.0-3 (залежать від реалізації попередніх пунктів та коду)

Якщо не зазначено інше, то працюємо з цілочисловими елементами.
Вважати, що послідовності зображуються списками.
Множини також зображуються списками.
Відношення зображуються списками пар елементів. 
Пара елементів зображується або списком з двох елементів, або власним типом.
Множини з повтореннями задаються списками пар вигляду (елемент, кількість входжень).
Графи можуть задаватися або списком ребер, де кожне ребро є парою вершин; або структурою суміжності (списком пар вигляду (вершина, список суміжних ребер)).
Дерево може зображуватись або власним типом, або "плоско" списками   (вершина (піддерево) (піддерево), (5 (1 (2) ()) (4))

4. Для множин з повтореннями реалізувати операцію перетину.

Реалізовано на Scala.